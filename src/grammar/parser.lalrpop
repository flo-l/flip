use std::str::FromStr;
use ::value::Value;
use ::grammar::unescape_string;
use super::lexer::{Token, Error};

grammar<'input>(text: &'input str);

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'input> {
        OpenParen => Token::OpenParen,
        ClosingParen => Token::ClosingParen,
        Dot => Token::Dot,
        Quote => Token::Quote,
        WhiteSpace => Token::WhiteSpace,
        Chr => Token::Char(<char>),
        Int => Token::Integer(<i64>),
        Str => Token::String(<&'input str>),
        Sym => Token::Symbol(<&'input str>),
    }
}

pub Char: Value = {
    <c:Chr> => Value::new_char(c),
};

pub Integer: Value = {
    <i:Int> => Value::new_integer(i),
};

pub Symbol: Value = {
   <s:Sym> => {
       match s {
           "true" => Value::new_bool(true),
           "false" => Value::new_bool(false),
           s => Value::new_symbol(s),
       }
   },
};

pub String: Value = {
   <s:Str> => Value::new_string(unescape_string(s)),
};

Item: Value = {
    Char,
    Integer,
    Symbol,
    String,
};
