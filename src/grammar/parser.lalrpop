use std::iter;
use ::value::Value;
use ::string_interner::StringInterner;
use ::grammar::lexer::unescape_string;
use super::lexer::Token;
use super::error::Error;

grammar<'input>(text: &'input str, interner_valid: bool, interner: &mut StringInterner);

extern {
    type Location = usize;
    type Error = Error;

    enum Token<'input> {
        OpenParen => Token::OpenParen,
        ClosingParen => Token::ClosingParen,
        Dot => Token::Dot,
        Quote => Token::Quote,
        WhiteSpace => Token::WhiteSpace,
        Begin => Token::Begin,
        Define => Token::Define,
        If => Token::If,
        Let => Token::Let,
        Loop => Token::Loop,
        Lambda => Token::Lambda,
        Recur => Token::Recur,
        Chr => Token::Char(<char>),
        Int => Token::Integer(<i64>),
        Str => Token::String(<&'input str>),
        Sym => Token::Symbol(<&'input str>),
    }
}

Char: Value = {
    <c:Chr> => Value::new_char(c),
};

pub Integer: Value = {
    <i:Int> => Value::new_integer(i),
};

// symbol which is not the name of a special form
NonSpecialSymbol: Value = {
   <s:Sym> => {
       match s {
           "true" => Value::new_bool(true),
           "false" => Value::new_bool(false),
           s => {
               assert!(interner_valid, "internal error: interner not set");
               Value::new_symbol(interner.intern(s))
           },
       }
   },
};

// symbol which is the name of a special form
SpecialSymbol: Value = {
    Begin => Value::new_symbol(interner.intern("begin")),
    Define => Value::new_symbol(interner.intern("define")),
    If => Value::new_symbol(interner.intern("if")),
    Let => Value::new_symbol(interner.intern("let")),
    Loop => Value::new_symbol(interner.intern("loop")),
    Lambda => Value::new_symbol(interner.intern("lambda")),
    Recur => Value::new_symbol(interner.intern("recur")),
};

// all valid symbols
Symbol: Value = {
    NonSpecialSymbol,
    SpecialSymbol,
};

String: Value = {
   <s:Str> => Value::new_string(unescape_string(s)),
};

EmptyList: Value = {
    OpenParen WhiteSpace? ClosingParen => Value::empty_list(),
};

Pair: Value = {
    OpenParen WhiteSpace? <a:NonSpecialItem> WhiteSpace Dot WhiteSpace <b:Item> WhiteSpace? ClosingParen
    => Value::new_pair(a, b),
};

List: Value = {
    EmptyList,

    // one element
    OpenParen WhiteSpace? <elem: NonSpecialItem> WhiteSpace? ClosingParen => {
        Value::new_list(&[elem])
    },

    // 2+ elements
    OpenParen WhiteSpace? <first: NonSpecialItem> WhiteSpace <v:(Item WhiteSpace)*> <last:Item> WhiteSpace? ClosingParen => {
        let first = iter::once(first);
        let middle = v.into_iter().map(|(v, _)| v);
        let last = iter::once(last);
        let values: Vec<Value> = first.chain(middle).chain(last).collect();
        Value::new_list(&values)
    },
};

#[inline]
Code: Vec<Value> = {
    <code:(WhiteSpace Item)+> => {
        code.into_iter().map(|(_, v)| v).collect()
    }
};

SpecialFormBegin: Value = {
    OpenParen WhiteSpace? Begin <code:Code> WhiteSpace? ClosingParen => {
        let begin = iter::once(Value::new_symbol(interner.intern("begin")));
        let values: Vec<Value> = begin.chain(code.into_iter()).collect();
        Value::new_list(&values)
    },
};

SpecialFormBeginTailCall: Value = {
    OpenParen WhiteSpace? Begin <code:Code?> WhiteSpace <last:TailCall> WhiteSpace? ClosingParen => {
        let begin = iter::once(Value::new_symbol(interner.intern("begin")));
        let code = code.into_iter().flat_map(|x| x.into_iter());
        let last = iter::once(last);
        let values: Vec<Value> = begin.chain(code).chain(last).collect();
        Value::new_list(&values)
    },
};

SpecialFormDefine: Value = {
    OpenParen WhiteSpace? Define WhiteSpace <name:Symbol> WhiteSpace <expr:Item> WhiteSpace? ClosingParen => {
        let define = Value::new_symbol(interner.intern("define"));
        Value::new_list(&[define, name, expr])
    },
};

SpecialFormIf: Value = {
    OpenParen WhiteSpace? If WhiteSpace <cond:Item> WhiteSpace <then:Item> WhiteSpace <els:Item> WhiteSpace? ClosingParen => {
        Value::new_list(&[Value::new_symbol(interner.intern("if")), cond, then, els])
    },
};

BindingList: Vec<Value> = {
    OpenParen WhiteSpace? ClosingParen => {
        vec![]
    },

    OpenParen WhiteSpace? <name:Symbol> WhiteSpace <expr:Item> <rest:(WhiteSpace Symbol WhiteSpace Item)*> WhiteSpace? ClosingParen => {
        // make it linear again for now
        let name = iter::once(name);
        let expr = iter::once(expr);
        let rest = rest.into_iter().flat_map(|(_, name, _, expr)| iter::once(name).chain(iter::once(expr)));
        name.chain(expr).chain(rest).collect()
    },
};

SpecialFormLet: Value = {
    OpenParen WhiteSpace? Let WhiteSpace <bindings:BindingList> <code:Code> WhiteSpace? ClosingParen => {
        let begin = iter::once(Value::new_symbol(interner.intern("let")));
        let bindings = iter::once(Value::new_list(&bindings));
        let values: Vec<Value> = begin.chain(bindings).chain(code.into_iter()).collect();
        Value::new_list(&values)
    },
};

SpecialFormLoop: Value = {
    // without tail call
    OpenParen WhiteSpace? Loop WhiteSpace <bindings:BindingList> <code:Code> WhiteSpace? ClosingParen => {
        let begin = iter::once(Value::new_symbol(interner.intern("loop")));
        let bindings = iter::once(Value::new_list(&bindings));
        let code = code.into_iter();
        let values: Vec<Value> = begin.chain(bindings).chain(code).collect();
        Value::new_list(&values)
    },

    // with tail call
    OpenParen WhiteSpace? Loop WhiteSpace <bindings:BindingList> <code:Code?> <last:TailCall> WhiteSpace? ClosingParen => {
        let begin = iter::once(Value::new_symbol(interner.intern("loop")));
        let bindings = iter::once(Value::new_list(&bindings));
        let code = code.into_iter().flat_map(|x| x.into_iter());
        let last = iter::once(last);
        let values: Vec<Value> = begin.chain(bindings).chain(code).chain(last).collect();
        Value::new_list(&values)
    },
};

LambdaArgs: Vec<Value> = {
    OpenParen WhiteSpace? ClosingParen => {
        vec![]
    },

    OpenParen WhiteSpace? <first:Symbol> <args:(WhiteSpace Symbol)*> WhiteSpace? ClosingParen => {
        let first = iter::once(first);
        let rest = args.into_iter().map(|(_, v)| v);
        first.chain(rest).collect()
    }
};

SpecialFormLambda: Value = {
    // without tail call
    OpenParen WhiteSpace? Lambda WhiteSpace <name:(Symbol WhiteSpace)?> <args:LambdaArgs> <code:Code> WhiteSpace? ClosingParen => {
        let begin = iter::once(Value::new_symbol(interner.intern("lambda")));
        let name = name.map(|(name, _)| name);
        let args = iter::once(Value::new_list(&args));
        let values: Vec<Value> = begin.chain(name).chain(args).chain(code.into_iter()).collect();
        Value::new_list(&values)
    },

    // with tail call
    OpenParen WhiteSpace? Lambda WhiteSpace <name:(Symbol WhiteSpace)?> <args:LambdaArgs> <code:Code?> WhiteSpace <last:TailCall> WhiteSpace? ClosingParen => {
        let begin = iter::once(Value::new_symbol(interner.intern("lambda")));
        let name = name.map(|(name, _)| name);
        let args = iter::once(Value::new_list(&args));
        let code = code.into_iter().flat_map(|x| x.into_iter());
        let last = iter::once(last);
        let values: Vec<Value> = begin.chain(name).chain(args).chain(code).chain(last).collect();
        Value::new_list(&values)
    },
};

SpecialFormRecur: Value = {
    OpenParen WhiteSpace? Recur <args:Code?> WhiteSpace? ClosingParen => {
        let begin = iter::once(Value::new_symbol(interner.intern("recur")));
        let args = args.into_iter().flat_map(|x| x.into_iter());
        let values: Vec<Value> = begin.chain(args).collect();
        Value::new_list(&values)
    },
};

// everything except for names of special forms and tail calls
NonSpecialItem: Value = {
    Quote <Item> => {
        assert!(interner_valid, "internal error: interner not set");
        Value::new_list(&[Value::new_symbol(interner.intern("quote")), <>])
    },
    Char,
    Integer,
    NonSpecialSymbol,
    String,
    Pair,
    List,
    SpecialFormBegin,
    SpecialFormDefine,
    SpecialFormIf,
    SpecialFormLet,
    SpecialFormLoop,
    SpecialFormLambda,
};

#[inline]
Item: Value = {
    NonSpecialItem,
    SpecialSymbol,
};

TailCall: Value = {
    SpecialFormRecur,
    SpecialFormBeginTailCall,
};

pub TopLevelItem: Value = {
    WhiteSpace? <Item> WhiteSpace?
};
